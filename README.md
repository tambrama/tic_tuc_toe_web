### Описание проекта

Этот репозиторий содержит серверную часть игры, в которой **два игрока** могут подключаться к партии и делать ходы через HTTP‑API.  
Проект написан на Go и разделён на отдельные слои (transport, services, repository, database), что облегчает дальнейшее развитие логики игры.

Добавляется и развивается **логика пошаговой игры между двумя игроками** (создание партии, подключение второго игрока, валидация ходов, определение победителя и завершение игры).

### Основные компоненты

- **`cmd/app/main.go`**: точка входа приложения, инициализация конфигурации, БД, DI‑контейнера и HTTP‑сервера.
- **`internal/app/app.go`**: сборка приложения, запуск серверов и инфраструктуры.
- **`internal/config/config.go`**: загрузка и хранение конфигурации (порты, строки подключения к БД и т.д.).
- **`internal/database`**:
  - **`connection.go`**: установка соединения с базой данных;
  - **`migrations.go`**: применение миграций (создание таблиц, в т.ч. для игр и ходов).
- **`internal/auth`**:
  - **`models.go`**: модели данных, связанные с пользователями/сессиями;
  - **`services.go`**: бизнес‑логика аутентификации/авторизации.
- **`internal/models/models.go`**: доменные модели (игра, игрок, ход, состояние игры).
- **`internal/repository`**:
  - **`repository.go`**: общие интерфейсы работы с БД;
  - **`game_repository.go`**: реализация хранения и загрузки сущностей игры (партия, ходы, состояние);
  - **`dto/dto.go`**, **`mappers/mappers.go`**: преобразование структур БД в доменные модели и обратно.
- **`internal/services`**:
  - **`services.go`**: общие сервисы;
  - **`game_services.go`**: основная **логика игры между двумя игроками**:
    - создание новой партии;
    - подключение второго игрока;
    - приём и валидация ходов;
    - смена активного игрока;
    - определение окончания игры (победа/ничья/принудительное завершение);
    - формирование ответа для клиента.
- **`internal/http`**:
  - **`handler/game_handler.go`**: HTTP‑обработчики для игровых эндпоинтов (создание игры, подключение, ход, получение состояния);
  - **`dto/dto.go`**, **`mappers/mappers.go`**: структуры запросов/ответов и маппинг с доменными моделями;
  - **`middleware/middleware.go`**: общие HTTP‑middleware (логирование, аутентификация и т.п.).
- **`internal/server/server.go`**: поднятие HTTP‑сервера, маршрутизация, подключение обработчиков.
- **`index.html`**: (опционально) примитивный клиент/страница для тестирования запросов к серверу.
- **`Makefile`**: удобные команды для сборки/запуска/тестирования.

### Логика игры между двумя игроками

В рамках логики игры предполагается следующий базовый сценарий:

1. **Создание игры**
   - Клиент (первый игрок) вызывает эндпоинт, например `POST /api/game`.
   - В `game_services` создаётся новая партия, в БД сохраняется состояние: ID игры, игрок №1, статус (например, `waiting_for_player2`), пустое поле/начальное состояние.
   - В ответ возвращаются данные игры (ID, текущий статус и т.д.).

2. **Подключение второго игрока**
   - Второй игрок вызывает эндпоинт `POST /api/game/{id}/join`.
   - Сервис проверяет, что:
     - игра существует;
     - игра ещё не началась и ожидает второго игрока;
   - В игру добавляется второй игрок, статус меняется на `in_progress`, устанавливается, чей ход первый.

3. **Совершение хода**
   - Активный игрок отправляет запрос, например `POST /api/game/{id}/move`, с данными хода (координаты, действие и т.п.).
   - `game_services` выполняет:
     - проверку, что сейчас ход именно этого игрока;
     - проверку корректности хода (не занята ли клетка, не нарушено ли правило и т.д.);
     - применение хода к состоянию игры;
     - сохранение нового состояния и хода в БД.
   - После применения хода проверяется, не закончилась ли игра (выигрыш, ничья).
   - Если игра окончена — статус меняется на `finished`, сохраняется результат и победитель.
   - Если нет — ход передаётся следующему игроку.

4. **Получение состояния игры**
   - Любой из игроков может запросить, например, `GET /api/game/{id}`.
   - В ответ возвращается:
     - текущее состояние поля;
     - статус игры;
     - чей ход сейчас;
     - (при завершении) результат и победитель.

5. **Завершение или отмена игры**
   - Дополнительно может быть реализован эндпоинт для досрочного завершения игры (например, по тайм‑ауту, выходу игрока, сдаче).

Точные правила (размер поля, тип игры — крестики‑нолики, шашки и т.п.) описываются и реализуются в `internal/models` и `internal/services/game_services.go`.

### Запуск проекта

- **Сборка и запуск через Go:**

```bash
go mod tidy
go run ./cmd/app
```

- **Использование `Makefile`** (если определены цели `run`, `build` и т.д.):

```bash
make run
```

После запуска сервер слушает указанный в конфигурации порт (например, `:8080`), а игровые эндпоинты доступны по префиксу `/api/game`.

### Дальнейшее развитие логики игры

- **Расширение правил игры**: добавление новых типов игр, специальных правил, сложных состояний.
- **Матчмейкинг**: автоматический подбор оппонента вместо ручного указания ID игры.
- **История и статистика**: хранение истории партий, рейтинги игроков, статистика побед/поражений.
- **Реал‑тайм обновления**: переход с чистого HTTP‑поллинга на WebSocket или SSE для мгновенного обновления состояния у обоих игроков.

Документация будет дополняться по мере развития логики игры между двумя игроками и появления новых эндпоинтов.
